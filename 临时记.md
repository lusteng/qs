### 缓存
> 强缓存(Expires和Cache-Control)、协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)

浏览器发起HTTP请求到服务器，先检查强缓存

### 协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)

> Etag 优先级高于 Last-Modified，Last-Modified精确颗粒度只能精确到秒

1. Last-Modified / If-Modified-Since 过程

客户端在request header携带上If-Modified-Since(上次请求资源返回的Last-Modified)在客户端询问文件是否有更新，yes，返回资源， no, 返回304

2. Etag / If-None-Match

客户端在request header携带上If-None-Match(上次请求资源返回的Etag)，询问服务端该资源是否有更新，yes，返回资源， no, 返回304

### 缓存流程

<img src="./images/demo/cache-flow.png"/>

1. 客户端加载资源前，先根据请求头的expires和cache-control 判断是否命中强缓存? yes, 从缓存(from memory cache 内存缓存 或者 from disk cache)中读取缓存， no，发送请求

2. 服务器通过last-modified和etag验证资源是否命中协商缓存？ yes, 返回304，从本地缓存读取资源， no, 返回资源数据

3. 强缓存和协商缓存都没命中， 直接从服务器加载资源


Q：如何理解的前端性能优化？
前端性能优化体现在两个方面：1.让页面加载的更快。 2. 让页面使用的更流畅 
加载的更快，比如减少http请求数量，优化http请求时间，使用ssr降低白屏时间，
使用的更流畅，优化长列表加载展示性能、css使用尽量规避重排损耗性能、预加载、懒加载、避免闭包使用


Q：你在工作中做过的性能优化？
1. 优化过react定制化多选下拉组件，展示项数据过多加载性能，通过可视区伪装只展示需要看到的数据，用户下拉的时候替换上用户即将看到的内容
2. 以前在网通电商时，优化图片加载性能，将部分常用的图片存储在本地LS内，减少页面请求
3. 使用vue或react规避使用v-if或判断语句展示dom，降低重排造成的页面性能
4. 针对动画开启GPU加速 使用transform:translateY(0px)




















